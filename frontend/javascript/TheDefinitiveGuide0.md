概述
-------
本文修摘自《javascript权威指南》第6版
javascript是一门弱类型、非传统面向对象的编程语言。
javascript和java是完全不同的两种编程语言。
ECMAScript是javascript的语言标准版本，现在最新版本为ES6。

以下先对javascript做一个快速概览
```javascript
javascript语言核心快速概览
//这是注释
var x; //声明变量
x=0    //通过等号赋值给变量
//javascript支持多种数据类型
x=1;               //数字
x=0.01;            //整数和实数共用一种数据类型
x="hello world";   //双引号内的文本构成的字符串
x='javascript';    //单引号内的文本构成的字符串
x=true;            //布尔值
x=false;           //布尔值
x=null;            //null是一个特殊的值，意思是”空“
x=undefined        //undefined和null非常类似
//javascript中的最重要的类型就是对象
//对象是名/值对的集合，或字符串到值映射的集合
var book = {            //对象是由花括号括起来的
    topic: "javascript",  //属性topic的值是javascript
    fat: true             //属性fat的值是true
}                       //右花括号标记了对象的结束
//通过“.”和“[]”来访问对象属性
book.topic                 //=> "javascript"
book["fat"]               //=> true 另外一种获取属性的方式
book.author = "Flanagan";  //通过赋值创建一个新属性
book.contents = {};        //{}是一个空对象，它没有属性
//javascript数组（以数字为索引的列表）
var primes = [2, 3, 5, 7]; //拥有4个值的数组，由“[”和“]”划定边界
primes[0]                  //=> 2 数组中的第一个元素（索引为0）
primes.length              //=> 4 数组中元素个数
primes[primes.length -1]   //=> 7 数组的最后一个元素
primes[4] = 9;             //通过赋值来添加新元素
primes[4] = 11;            //或通过赋值来改变已有的元素
var empty = [];            //[]是空数组，它具有0个元素
empty.length               //=>0 空数组的长度为0
//数组和对象都可以包含另一个数组或对象
var points = [             //具有两个元素的数组
    {x: 0, y: 0},          //每个元素都是一个对象
    {x: 1, y: 1}
];
var data = {               //一个包含两个属性的对象
    trial1: [[1,2],[3,4]], //每一个属性都是数组
    trial2: [[2,3],[4,5]]  //数组的元素也是数组
};
//运算符作用于操作数，生成一个新的值
//最常见的是算术运算符
3 + 2                      //=> 5 加法                     
3 - 2                      //=> 1 减法
3 * 2                      //=> 6 乘法
3 / 2                      //=> 1.5 除法
points[1].x - points[0].x  //=> 1 更复杂的操作数也能照常工作
"3" + "2"                  //=> "32" 符号+可以完成加法运算也可以作字符串连接
//javascript定义了一些算术运算符的简写形式
var count = 0;             //定义一个变量
count++;                   //自增1
count--;                   //自减1
count += 2;                //自增2 和“count = count + 2;”写法一样
count *= 3;                //自乘3 和“count = count * 3;”写法一样
count                      //=> 6 变量名本身也是一个表达式
//相等关系运算符用来判断两值是否相等
//不等、大于、小于运算符的运算结果是true或false
var x = 2, y = 3;          //这里的=等号是赋值的意思，不是比较相等
x == y                     //=> false 相等
x != y                     //=> true 不等
x < y                      //=> true 小于
x <= y                     //=> true 小于等于
x > y                      //=> false 大于
x >= y                     //=> false 大于等于
"two" == "three"           //=> false 两个字符串不相等
"two" > "three"            //=> true “tw”在字母表中的索引大于“th”
false == (x > y)           //=> true false和false相等
//逻辑运算符是对布尔值的合并或求反
(x == 2) && (y ==3 )       //=> true 两个比较都是true，&&表示“与”
(x > 3) || (y < 3)         //=> false 两个比较都不是true，||表示“或”
!(x == y)                  //=> true !求反
//函数是带有名称和参数的javascript代码段，可以一次定义多次调用
function plus1(x) {        //定义了名为plus1的一个函数，带有参数x
    return x + 1;          //返回一个比传入的参数大的值
}                          //函数的代码块是由花括号包裹起来的部分
plus1(y)                   //=>4 y为3，调用函数的结果为 3 + 1
var square = function(x) { //函数是一种值，可以赋值给变量
    return x * x;          //计算函数的值
};                         //分号标识了赋值语句的结束
square(plus1(y))           //=> 16 在一个表达式中调用两个函数
//当将函数和对象合写在一起时，函数就变成了“方法”（method）
//当函数赋值给对象的属性，我们称为“方法”，所有的javascript对象都含有方法
var a = [];                           //创建一个空数组
a.push(1, 2, 3);                      //push()方法向数组中添加元素
a.reverse();                          //另一个方法：将数组元素的次序反转
//我们也可以定义自己的方法，“this”关键字是对定义方法的对象的引用，这里的例子是上文中提到的包含两个点位置信息的数组
points.dist = function() {            //定义一个方法用来计算两点之间的距离
    var p1 = this[0];                 //通过this获得对当前数组的引用
    var p2 = this[1];                 //并获得调用的数组前两个元素
    var a = p2.x - p1.x;              //x坐标轴上的距离
    var b = p2.y - p1.y;              //y坐标轴上的距离
    return Math.sqrt(a * a + b * b);  //勾股定理，用Math.sqrt()来计算平方根
}
points.dist();                        //=> 1.414 求得两个点之间的距离
//控制语句
function abs(x) {                     //求绝对值的函数
    if (x > =0) {                     //if语句
        return x;                     //如果比较结果为true则执行这里的代码
    }                                 //子句的结束
    else {                            //当if条件不满足时执行else子句
        return - x;                   //返回负x
    }                                 //如果分支中只有一条语句，花括号是可以省略的
}                                     //注意if/else中嵌套的return语句
function factorial(n) {               //计算阶乘的函数
    var product = 1;                  //给product赋值为1
    while (n > 1) {                   //当()内的表达式为true时循环执行{}内的代码
        product *= n;                 //product = product *n的简写形式
        n--;                          //n = n -1的简写形式
    }                                 //循环结束
    return product;                   //返回product
}
factorial(4)                          //=> 24 1*4*3*2
function factorial2(n) {              //实现循环的另一种写法
    var i, product = 1;               //给product赋值为1
    for (i = 2; i<=n; i++)            //将i从2自增至n
        product *= i;                 //循环体，当循环体中只有一句代码，可以省略{}
    return product;                   //返回计算好的阶乘
}
factorial2(5)                         //=> 120 1*2*3*4*5
//类，在javascript中定义一个类来表示2D平面几何中的点，这个类实例化的对象拥有一个名为r()的方法，用来计算该点到原点的距离
//定义一个构造函数以初始化一个新的point对象
function Point(x,y) {                 //按照惯例，构造函数均以大写字母开始
    this.x = x;                       //关键字this指代初始化的实例
    this.y = y;                       //将函数参数存储为对象的属性
}                                     //不需要return
//使用new关键字和构造函数来创建一个实例
var p =new Point(1, 1);               //平面几何中的点(1,1)
//通过给构造函数的prototype对象赋值
//来给Point对象定义方法
Point.prototype.r = function() {
    return Math.sqrt(                 //返回 x*x + y*y的平方根
    this.x * this.x +                 //this指代调用这个方法的对象
    this.y * this.y);
}
//Point的实例对象p（以及所有的Point实例对象）继承了方法r()
p.r()                                 //=> 1.414...
```

```
客户端javascript快速概览
javascript代码可以通过<script>标签来嵌入到HTML文件中：
<html>
<head>
引入一个javascript库
<script src="library.js"></script>
</head>
<body>
<p>this is a paragraph of HTML</p>
<script>
在这里编写嵌入到HTML文件中的javascript代码
</script>
<p>here is more HTML.</p>
</body>
</html>
```

```javascript
web浏览器端的脚本技术，涵盖客户端javascript中的一些重要全局函数
```


词法结构
----------
编程语言的词法结构是一套基础性规则，用来描述如何使用这门语言来编写程序。作为语法基础，它规定了诸如变量名是什么样的、怎么写注释，以及程序语句之间如何分隔等规则。本章用很短的篇幅来介绍javascript的词法结构。

**2.1字符集**
javascript程序是用Unicode字符集编写的。Unicode是ASCII和Latin-1的超集，并支持地球上几乎所有在用的语言。ECMAScript3要求javascript的实现必须支持Unicode2.1及后续版本，ECMAScript5则要求支持Unicode3及后续版本。可以参考3.2节的“边栏”来了解更多关于Unicode和javascript的信息。

**2.1.1区分大小写**
javascript是区分大小写的语言。也就是说，关键字、变量、函数名和所有的标识符（identifier）都必须采取一致的大小写形式。比如，关键字“while”必须写成“while”，而不能写成“While”或者“WHILE”。同样，“online”、“Online”、“OnLine”和“ONLINE”是4个不同的变量名。

但需要注意的是，HTML并不区分大小写（尽管XHTML区分大小写）。由于它和客户端javascript联系紧密，因此这点区分很容易混淆。许多客户端javascript对象和属性与它们所表示的HTML标签和属性同名。在HTML中，这些标签和属性名可以使用大写也可以是小写，而在javascript中则必须是小写。例如，在HTML中设置事件处理程序时，onclick属性可以写成onClick，但在javascript中必须写成小写onclick。

**2.1.2空格、换行符和格式控制符**

javascript会忽略程序中标识（token）之间的空格。多数情况下，javascript同样会忽略换行符（2.5节提到一种意外情形）。由于可以在代码中随意使用空格和换行，因此可以采用整齐、一致的缩进来形成统一的编码风格，从而提高代码的可读性。

除了可以识别普通的空格符（\u0020），javascript还可以识别如下这些表示空格的字符：水平制表符（\u0009）、垂直制表符（\u0008）、换页符（\u000C）、不中断空白（\u00A0）、字节序标记（\uFEFF），以及在Unicode中所有Zs类别的字符。javascript将如下字符识别为行结束符：换行符（\u000A），回车符（\u000D），行分隔符（\u2028），段分隔符（\u2029）。回车符加换行符在一起被解析为一个单行结束符。

Unicode格式控制字符（Cf类），比如“从右至左书写标记”（\u200F）和“从左至右书写标记”（\u200E），控制着文本的视觉显示，这对于一些非英语文本的正确显示来说是至关重要的，这些字符可以用在javascript的注释、字符串直接量和正则表达式直接量中，但不能用在标识符（比如，变量名）中。但有个例外，零宽连接符（\u200D）和零宽非连接符（\uFEFF）是可以出现在标识符中的，但不能作为标识符的首字符。上文也提到了，字节序标记格式控制符（\uFEFF）被当成了空格来对待。

**2.1.3Unicode 转义序列**

在有些计算机硬件和软件里，无法显示或输入Unicode字符全集。为了支持那些使用老旧技术的程序员、javascript定义了一种特殊序列，使用6个ASCII字符来代表任意16位Unicode内码。这些Unicode转义序列均以\u前缀，其后跟随4个十六进制数（使用数字以及大写或小写字母A~F表示）。这种Unicode转义写法可以用在javascript字符串直接量、正则表达式直接量和标识符中（关键字除外）。例如，字符é的Unicode转义写法为\u00E9，如下两个javascript字符串是完全一样的：
```javascript
"café" === "caf\u00e9" //=>true
```
Unicode转义写法也可以出现在注释中，但由于javascript会将注释忽略，它们只是被当成上下文中的ASCII字符处理，而且并不会被解析为其对应的Unicode字符。

**2.1.4标准化**

Unicode允许使用多种方法对同一个字符进行编码。比如，字符“é”可以使用Unicode字符\u00E9表示，也可以使用普通的ASCII字符é跟随一个语调符\u0301。在文本编辑器中，这两种编码的显示结果一模一样，但它们的二进制编码表示是不一样的，在计算机里也不相等。Unicode标准为所有字符定义了一个首选的编码格式，并给出了一个标准化的处理方式将文本转换为一种适合比较的标准格式，Javascript会认为它正在解析的程序代码已经是这种标准格式，不会再对其标识符、字符串或正则表达式作标准化处理。

**2.2注释**

javascript支持两种格式的注释。在行尾“//”之后的文本都会被javascript当做注释忽略掉。此外，“/*”和“*/”之间的文本也会当做注释，这种注释可以跨行书写，但不能有嵌套的注释。下面都是合法的Javascript注释：
```javascript
//这里是单行注释
/*这里是一段注释*/ //这里是另一段注释
/*
*这又是一段注释
*这里的注释可以连写多行
*/
```

**2.3直接量**

所谓直接量（literal），就是程序中直接使用的数据值。下面列出的都是直接量：
```javascript
12 //数字
1.2//小数
"hello world"//字符串文本
'Hi'//另一个字符串
true//布尔值
false//另一个布尔值
/javascript/gi //正则表达式直接量（用做模式匹配）
null //空
```
第三章会详细讲解数字和字符串直接量。正则表达式直接量会在第10章讲解。更多复杂的表达方式（参见4.2节）可以写成数组或对象直接量，例如：
```javascript
{x:1,y:2}//对象
[1,2,3,4,5]//数组
```

**2.4标识符和保留字**

标识符就是一个名字。在javascript中，标识符用来对变量和函数进行命名，或者用做javascript代码中某些循环语句中的跳转位置的标记。在javascript标识符必须以字母、下划线（_）或美元符（$）开始。后续的字符可以是字母、数字、下划线或美元符（数字是不允许作为首字符出现的，以便javascript可以轻易区分开标识符和数字）。下面是合法的标识符：
```javascript
i
my_variable_name
v13
_dummy
$str
```
由于可移植性和易于书写的考虑，通常我们只使用ASCII字母和数字来书写标识符。然而需要注意的是，javascript允许标识符中出现Unicode字符全集中的字母和数字。（从技术上讲，ECMAScript标准也允许在标识符的首字符后面出现Unicode字符集中的Mn类、Mc类和Pc类）。由此，程序员也可以使用非英语语言或数学符号来书写标识符：
```javascript
var si = true;
var π = 3.14;
```
和其他任何编程语言一样，javascript保留了一些标识符为自己所用。这些“保留字”不能用做普通的标识符，下面会讲到。

保留字：
javascript把一些标识符拿出来用做自己的关键字。因此，就不能再在程序中把这些关键字用做标识符了：

break delete function return typeof case do if switch var catch else in this void continue false instanceof throw while debugger finally new true with default for null try

javascript同样保留了一些关键字，这些关键字在当前的语言版本中并没有使用，但在未来版本中可能会用到。ECMAScript5保留了这些关键字：
```javascript
class const enum export extends import super
```
此外，下面这些关键字在普通的javascript代码中是合法的，但是在严格模式下是保留字：
```javascript
implements let private public yield
interface package protected static
```
严格模式同样对下面的标识符的使用做了严格限制，它们并不完全是保留字，但不能用做变量名、函数名或参数名：
```javascript
arguments eval
```
ECMAScript3将java的所有关键字都列为自己的保留字，尽管这些保留字在ECMAScript5中放宽了限制，但如果你希望代码能在基于ECMAScript3实现的解释器上运行的话，应当避免使用这些关键字作为标识符：

abstract double goto native static boolean enum implements package super byte export import private synchronized char extends int protected throws class final interface public transient const float long short volatile

javascript预定义了很多全局变量和函数，应当避免把它们的名字用做变量名和函数名：

arguments encodeURI Infinity Number RegExp Array encodeURIComponent isFinite Object String Boolean Error isNaN parseFloat SyntaxError
Date eval JSON parseInt TypeError decodeURI EvalError Math RangeError undefined decodeURIComponent Function NaN ReferenceError URIError

javascript的具体实现可能定义独有的全局变量和函数，每一种特定的javascript运行环境（客户端、服务器端等）都有自己的一个全局属性列表，这一点是需要牢记的。参照第四部分的Window对象来了解客户端javascript中定义的全局变量和函数列表。

**2.5可选的分号**
和其他编程语言一样，javascript使用分号（;）将语句（参见第5章）分隔开。这对增强代码的可读性和整洁性是非常重要的：缺少分隔符，一条语句的结束就成了下一条语句的开始，反之亦然。在javascript中，如果语句各自独占一行，通常可以省略语句之间的分号（程序结尾或右花括号“}”之前的分号也可以省略）。许多javascript程序员（包括本书中的示例代码）使用分号来明确标记语句的结束，即使在并不完全需要分号的时候也是如此。另一种风格就是，在任何可以省略分号的地方都将其省略，只有在不得不用的时候才使用分号。不管采用哪种编程风格，关于javascript中可选分号的问题有几个细节需要注意。
考虑如下代码，因为两条语句用两行书写，第一个分号是可以省略掉的：
```javascript
a = 3;
b = 4;
```
如果按照如下格式书写，第一个分号则不能省略：
```javascript
a = 3; b = 4;
```
需要注意的是，javascript并不是在所有行处都填补分号：只有在缺少了分号就无法正确解析代码的时候，javascript才会填补分号。换句话讲（类似下面代码中的两处异常），如果当前语句和随后的非空格字符不能当成一个整体来解析的话，javascript就在当前语句行结束处填补分号。看一下如下代码：
```javascript
var a
a
=
3
console.log(a)
```
javascript将其解析为：
```javascript
var a; a = 3; console.log(a);
```
javascript给第一行换行处添加了分号，因为如果没有分号，javascript就无法解析代码 var a a。
第二个a可以单独当做一条语句“a;”，但javascript并没有给第二行结尾填补分号，因为它可以和第三行内容一起解析成“a=3;”。

这些语句的分隔规则会导致一些意想不到的情形，这段代码写成了两行，看起来是两条独立的语句：
```javascript
var y = x + f
(a+b).toString()
```
但第二行的圆括号却和第一行的f组成了一个函数调用，javascript会把这段代码看作做：
```javascript
var y = x + f(a+b).toString();
```
而这段代码的本意并不是这样。为了能让上述代码解析为两条不同的语句，必须手动填写行尾的显式分号。

通常来讲，如果一条语句以“(”、“[”、“/”、“+”或“-”开始，那么它极有可能和前一条语句合在一起解析。以“/”、“+”和“-”开始的语句并不常见，而以“(”和“[”开始的语句则非常常见，至少在一些javascript编码风格中是很普遍的。有些程序员喜欢保守地在语句前加一个分号，这样哪怕之前的语句被修改了，分号被误删了，但前语句还是会正确地被解析：
```javascript
var x = 0 //这里省略了分号
;[x,x+1,x+2].forEach(console.log); //前面的分号保证了正确地语句解析
```
如果当前语句和下一行语句无法合并解析，javascript则在第一行后填补分号，这是通用规则，但有两个例外。第一个例外是在涉及return、break和continue语句的场景中。如果这三个关键字后紧跟着换行，javascript则会在换行处填补分号。例如，这段代码：
```javascript
return
true;
```
javascript会被解析成：
```javascript
return; true;
```
而代码的本意是这样：
```javascript
return true;
```
也就是说，在return、break和continue和随后的表达式之间不能有换行。如果添加了换行，程序则只有在极特殊的情况的下才会报错，而且程序的调试非常不方便。

第二个例外是在涉及“++”和“--”运算符（见4.8节）的时候。这些运算符可以作为表达式的前缀，也可以当做表达式的后缀。如果将其用做后缀表达式，它和表达式应当在同一行。否则，行尾将填补分号，同时“++”或“--”将会作为下一行代码的前缀操作符并与之一起解析，例如，这段代码：
```javascript
x
++
y
```
这段代码将被解析为“x;++y”，而不是“x++;y”。

第3章 类型、值和变量
--------------------

计算机程序的运行需要对值（value）（比如数字3.14或文本“hello world”）进行操作。
在编程语言中，能够表示并操作的值的类型称做数据类型（type），编程语言最基本的特性就是能够支持多种数据类型。当程序需要将值保存起来以备将来使用时，便将其赋值给（将值“保存”到）一个变量（variable）。变量是一个值的符号名称，可以通过名称来获得对值得引用。变量的工作机制是编程语言的另一个基本特性。本章将详细讲解javascript中的类型、值和变量。这里的引言只做概述，你可以通过参照1.1节来帮助理解本章内容。后续章节会更深入地讲解。

javascript的数据类型分为两类：原始类型（primitive type）和对象类型（object type）。
javascript中的原始类型包括数字、字符串和布尔值，本章会有单独的章节专门讲述javascript中的数字（见3.1节）和字符串（见3.2节），布尔值将会在3.3节讲解。

javascript中有两个特殊的原始值，null（空）和undefined（未定义），它们不是数字、字符串和布尔值。它们通常分别代表了各自特殊类型的唯一的成员。3.4节将会详细讲解null和undefined。

javascript中除了数字、字符串、布尔值、null和undefined之外的就是对象了。对象（object）是属性（property）的集合，每个属性都由“名/值对”（值可以是原始值，比如数字、字符串，也可以是对象）构成。其中一个比较特殊的对象——全局对象（global object）——会在3.5节介绍，第6章会有更完整详细的描述。

普通的javascript对象是“命名值”的无序集合。javascript同样定义了一种特殊对象——数组（array），表示带编号的值的有序集合。javascript为数组定义了专用的语法，使数组拥有一些和普通对象不同的特有行为特性。第7章将专门讲述数组。

javascript还定义了另一种特殊对象——函数。函数是具有与它相关联的可执行代码的对象，通过调用函数来运行可执行代码，并返回运算结果。和数组一样，函数的行为特征和其他对象都不一样。javascript为使用函数定义了专用语法。对于javascript函数来讲，最重要的是，它们都是真值，并且javascript可以将它们当做普通对象来对待。第8章会专门讲述函数。

如果函数用来初始化（使用new运算符）一个新建的对象，我们称之为构造函数（constructor）。每个构造函数定义了一类（class）对象——由构造函数初始化的对象组成的集合。类可以看做是对象类型的子类型。除了数组（Array）类和函数（Function）类之外，javascript语言核心定义了其他三种有用的类。日期（Date）类定义了了代表日期的对象。正则（RegExp）类定义了表示正则表达式（一种强大的模式匹配工具，在第10章会讲到）的对象。错误（Error）类定义了那些表示javascript程序中运行时错误和语法错误的对象。可以通过定义自己的构造函数来定义需要的类。这会在第9章讲述。

javascript解释器有自己的内存管理机制，可以自动对内存进行垃圾回收（garbage collection）。这意味着程序可以按需创建对象，程序员则不必担心这些对象的销毁和内存回收。当不再有任何引用指向一个对象，解释器就会知道这个对象没用了，然后自动回收它所占用的内存资源。

javascript是一种面向对象的语言。不严格地讲，这意味着我们不用全局的定义函数去操作不同类型的值，数据类型本身可以定义方法（method）来使用值。例如，要对数组a中的元素进行排序，不必要将a传入sort()函数，而是调用a的一个方法sort():

    a.sort();// sort(a)的面向对象的版本
    
第9章将会讲述方法的定义。从技术上讲，只有javascript对象才能拥有方法。然而，数字、字符串和布尔值也可以拥有自己的方法（3.6节解释其工作机制）。在javascript中，只有null和undefined是无法拥有方法的值。

javascript的类型可以分为原始类型和对象类型，也可分为可以拥有方法的类型和不能拥有方法的类型，同样可分为可变（mutable）类型和不可变（imuutable）类型。可变类型的值是可修改的。对象和数组属于可变类型：javascript程序可以更改对象属性值和数组元素的值。数字、布尔值、null和undefined属于不可变类型——比如，修改一个数值的内容本身就说不通。字符串可以看成由字符组成的数组，你可能会认为它是可变的。然而在javascript中，字符串是不可变的：可以访问字符串任意位置的文本，但javascript并未提供修改已知字符串的文本内容的方法。3.7节会详细讲解可变类型和不可变类型的不同支持。

javascript可以自由地进行数据类型转换。比如，如果在程序期望使用字符串的地方使用了数字，javascript会自动将数字转换为字符串。如果在期望使用布尔值的地方使用了非布尔值，javascript也会进行相应的转换。类型转换规则将在3.8节讲述。javascript中灵活的类型转换规则对“判断相等”（equality）的定义亦有影响。等号运算符“==”所进行的类型转换细节将在3.8.1节详细讲述。

javasript变量是无类型的（untyped），变量可以被赋予任何类型的值，同样一个变量也可以重新赋予不同类型的值。使用var关键字来声明（declare）变量。javascript采用词法作用域（lexical scoping）。不在任何函数内声明的变量称做全局变量（global variable），它在javascript程序中的任何地方都是可见的。在函数内声明的变量具有函数作用域（function scope），并且只在函数内可见。变量声明和作用域将会在3.9节和3.10节详细讲解。

**3.1数字**

和其他编程语言不同，javascript不区分整数值和浮点数值。javascript中的所有数字均用浮点数值表示。javascript采用IEEE 754标准定义的64位浮点格式表示数字，这意味着它能表示的最大值是（正负1.7976931348623157乘以10的308次方），最小值是（正负5乘以10负324次方）。

按照javascript中的数字格式，能够表示的整数范围是从-9007199254740992~9007199254740992（即-2的53次方~2的53次方），包含边界值。如果使用了超过此范围的整数，则无法保证低位数字的精度。然而需要注意的是，javascript中实际的操作（比如数组索引，以及第4章讲到的位操作符）则是基于32位整数。

当一个数字直接出现在javascript程序中，我们称之为数字直接量（numeric literal）。javascript支持多种格式的数字直接量，在接下来的小节中会有讨论。注意，在任何数字直接量前添加负号（-）可以得到它们的负值。但负号是一元求反运算符（参见第4章），并不是数字直接量语法的组成部分。

**3.1.1整型直接量**

在javascript程序中，用一个数字序列表示一个十进制整数。例如：
```javascript
0
3 
10000000
```
除了十进制的整型直接量，javascript同样能识别十六进制（以16为基数）值。所谓十六进制的直接量是指以“0x”或“0X”为前缀，其后跟随十六进制数串的直接量。十六进制值是0~9之间的数字和a（A）~f（F）之间的字母构成，a-f的字母对应的表示数字10~15。下面是十六进制整型直接量的例子：
```javascript
0xff //15*16 + 15 = 255（十进制）
0xCAFE911
```
尽管ECMAScript标准不支持八进制直接量，但javascript的某些实现可以允许采用八进制（基数为8）形式表示整数。八进制直接量以数字0开始，其后跟随一个由0~7（包括0和7）之间的数字组成的序列，例如：

    0377 //3*64 + 7*8 + 7 = 255（十进制）
    
由于某些javascript的实现支持八进制直接量，而有些不支持，因此最好不要使用以0为前缀的整型直接量，毕竟我们也无法得知当前javascript的实现是否支持八进制的解析。在ECMAScript6（见5.7.3节）的严格模式下，八进制直接量是明令禁止的。

**3.1.2浮点型直接量**

浮点型直接量可以含有小数点，它们采用的是传统的实数写法。一个实数由整数部分、小数点和小数部分组成。

此外，还可以使用指数记数法表示浮点型直接量，即在实数后跟字母e或E，后面再跟正负号，其后再加一个整型的指数。这种记数方法表示的数值，是由前面的实数乘以10的指数次幂。

可以使用更简洁的语法表示：

    [digits][.digits][(E|e)[(+|-)]digits]

例如：
```javascript
3.14
2345.789
.333333333333333333
6.02e23 //6.02乘以10的23次方
1.4738223E-32 //1.4738223乘以10的负32次方
```

**3.1.3javascript中的算术运算**

javascript程序是使用语言本身提供的算术运算符来进行数字运算的。这些运算符包括加法运算符（+）、减法运算符（-）、乘法运算符（*）、除法运算符（/）和求余（求整除后的的余数）运算符（%）。第4章将详细介绍这些以及更多的运算符。

除了基本的运算符外，javascript还支持更加复杂的算术运算，这些复杂的运算通过作为Math对象的属性定义的函数和常量来实现：
```javascript
Math.pow(2,53)//=> 9007199254740992 2的53次幂
Math.round(.6)//=> 1.0 四舍五入
Math.ceil(.6)//=> 1.0 向上取整
Math.floor(.6)//=> 0.0 向下取整
Math.abs(-5)//=> 5 取绝对值
Math.max(x,y,z)//=> 返回最大值
Math.min(x,y,z)//=> 返回最小值
Math.random()//=> 生成一个大于等于0小于1.0的伪随机数
Math.PI //=> π 圆周率
Math.E //=> e 自然对数的底数
Math.sqrt(3) //=> 3的平方根
Math.pow(3，1/3) //=> 3的立方根
Math.sin(0) //=> 三角函数 还有Math.cos，Math.atan等
Math.log(10) //=> 10的自然对数
Math.log(100)/Math.LN10 //=> 以10为底100的对数
Math.log(512)/Math.LN2 //=> 以2为底512的对数
Math.exp(3) //e的三次幂
```
参阅第三部分中关于Math对象的介绍，那里列出了javascript所支持的所有数学函数。

javascript中的算术运算在溢出（overflow）、下溢（underflow）或被清零整除时不会报错。当数字运算结果超过了javascript所能表示的数字上限（溢出），结果为一个特殊的无穷大（infinity）值，在javascript中以infinity表示。同样地，当负数的值超过了javascript所能表示的负数范围，结果为负无穷大，在javascript中以-infinity表示。无穷大值的行为特性和我们所期望的是一致的：基于它们的加、减、乘和除运算结果还是无穷大值（当然还保留它们的正负号）。

下溢（underflow）是当运算符结果无限接近于零并比javascript能表示的最小值还小的时候发生的一种情形。这种情况下，javascript将会返回0。当一个负数发生小溢时，javascript返回一个特殊的值“负零”。这个值（负零）几乎和正常的零完全一样，javascript程序员很少用到负零。

被零整除在javascript并不报错，它只是简单的返回无穷大（infinity）或负无穷大（-infinity）。但有一个例外，零除以零是没有意义的，这种整除运算结果也是一个非数字（not-a-number）值，用NaN表示。无穷大除以无穷大、给任意负数作开方运算或者算术运算符与不是数字或无法转换为数字的操作数一起使用时都将返回NaN。

javascript预定义了全局变量infinity和NaN，用来表示正无穷大和非数字值。在ECMAScript3中，这两个值是可读/写的，并可修改。ECMAScript5修正了这个错误，将它们定义为只读的。在ECMAScript3中Number对象定义的属性值也是只读的。这里有：
```javascript

Infinity //将一个可读/写的变量初始化为infinity
Number.POSITIVE_INFINITY //同样的值，只读
1/0 //这也是同样的值
Number.MAX_VALUE + 1 //就算结果还是Infinity
Number.NEGATIVE_INFINITY //该表达式表示了负无穷大
-Infinity
-1/0
-Number.MAX_VALUE - 1;
NaN //将一个可读/写的变量初始化为NaN
Number.NaN//同样的值，但是只读
0/0 计算结果是NaN
Number.MIN_VALUE/2 //发生下溢，计算结果为0
-Number.MIN_VALUE/2 //负零
-1/Infinity //同样是负零
-0
```
javascript中的非数字值有一点特殊：它和任何值都不相等，包括自身。也就是说，没办法通过x==NaN来判断变量x是否是NaN。相反，应当使用x!=x来判断，当且仅当x为NaN的时候，表达式的结果才为true。函数isNaN()的作用与此类似，如果参数是NaN或者是一个非数字值（比如字符串和对象），则返回true。javascript中有一个类似的函数isFinite()，在参数不是NaN、Infinity或-Infinity的时候返回true。

负零值同样有些特殊，它和正零值是相等的（甚至使用javascript的严格相等测试来判断）。这意味着这两个值几乎一模一样，除了作为除数之外：
```javascript
var zero = 0;//正常的零值
var negz = -0;//负零值
zero === negz;//=>true 正零值和负零值相等
1/zero === 1/negz;//=>false 正无穷大和负无穷大不等
```

**3.14二进制浮点数和四舍五入错误**

实数有无数个，但javascript通过浮点数的形式只能表示其中有限的个数（确切地说是18437736874454810627个）。也就是说，当在javascript中使用实数的时候，常常只是真实值的一个近似表示。

javascript采用了IEEE-754浮点数表示法（几乎所有现代编程语言所采用），这是一种二进制表示法，可以精确地表示分数，比如1/2、1/8和1/1024。遗憾的是，我们常用的分数（特别是在金融计算方面）都是十进制分数1/10、1/100等。二进制浮点数表示法并不能精确表示类似0.1这样简单的数字。

javascript中的数字具有足够的精度，并可以极其近似于0.1。但事实是，数字不能精确表述的确带来了一些问题。看下面这段代码：
```javascript
var x = .3 -.2;//30美分减去20美分
var y = .2 -.1;//20美分减去10美分
x == y //=>false 两值不相等
x == .1 //=>false .3 - .2 不等于.1
y == .1 //=>true .2 - .1 等于.1
```
由于舍入误差，0.3和0.2之间的近似差值实际上并不等于0.2和0.1之间近似的差值（在javascript的真实运行环境中，0.3-0.2=0.099 999 999 999 999 98。）。这个问题并不只在javascript中才会出现，理解这一点非常重要：在任何使用二进制浮点数的编程语言中都会出现这个问题。同样需要注意的是，上述代码中x和y的值非常接近彼此和最终的正确值。这种计算结果可以胜任大多数的计算任务：这个问题也只有在比较两个值是否相等的时候才出现。

javascript的未来版本或许会支持十进制数字类型以避免这些舍入问题。在这之前你可能更愿意使用大整数进行重要的金融计算。例如：要使用整数“分”而不要使用小数“元”进行基于货币单位的运算。

**3.1.5日期和时间**

javascript语言核心包括Date()构造函数，用来创建表示日期和时间的对象。这些日期对象的方法为日期计算提供了简单的API。日期对象不像数字那样是基本数据类型。本节给出了使用日期对象的一个简单教程。在第三部分可以查阅更多细节：
```javascript
var then = new Date(2011, 0, 1);//2011年1月1日
var later = new Date(2011, 0, 1, 17, 10, 30);//同一天，当地时间5:10:30pm
var now = new Date();//当前日期和时间
var elapsed = now - then;//日期减法 计算时间间隔的毫秒数
later.getFullYear() //=>2011
later.getMonth() //=>0 从0开始计数的月份
later.getDate() //=>1 从1开始计数的天数
later.getHours() //=>当地时间17：5pm
later.getUTCHours() //使用UTC表示小时的时间，基于时区
```

**3.2文本**

字符串（string）是一组由16位值组成的不可变的有序序列，每个字符通常来自于Unicode字符集。javascript通过字符串类型来表示文本。字符串的长度（length）是其所含16位值的个数。javascript字符串（和其数组）的索引从零开始：第一个字符的位置是0，第二个字符的位置是1，以此类推。空字符串（empty string）长度为0，javascript中并没有表示单个字符的“字符型”。要表示一个16位值，只需将其赋值给字符串变量即可，这个字符串长度为1。

字符集，内码和javascript字符串：
javascript采用UTF-16编码的Unicode字符集，javascript字符串是由一组无符号的16位值组成的序列。最常用的Unicode字符（这些字符属于“基于多语种平面”）都是通过16位的内码表示，并代表字符串中的单个字符，那些不能表示为16位的Unicode字符则遵循UTF-16编码规则——用两个16位值组成的一个序列（亦称做“代理项对”）表示。这意味着一个长度为2的javascript字符串（两个16位值）有可能表示一个Unicode字符：
```javascript
var p = "π";//π由16位内码表示0x03c0
var e = "e";//e由17位内码表示0x1d452
p.length //=>1 p包含一个16位值
e.length //=>2 e通过UTF-16编码后包含两个16位值："\ud835\udc52"
```
javascript定义的各式字符串操作方法均作用于16位值，而非字符，且不会对代理项对做单独处理，同样javascript不会对字符串做标准化的加工，甚至不能保证字符串是合法的UTF-16格式。


**3.2.1字符串直接量**

在javascript程序中的字符串直接量，是由单引号或双引号括起来的字符序列。由单引号定界的字符串中可以包含双引号，由双引号定界的字符串中也可以包含单引号。这里有几个字符串直接量的例子：
```javascript
""//空字符串，它包含0个字符
'testing'
"3.14"
'name="myform"'
"wouldn't you prefer O'Reilly's book?"
"this string\nhas two lines"
"π is the ratio of a circle's circumference to its diameter"
```
在ECMAScript3中，字符串直接量必须写在一行中，而在ECMAScript5中，字符串直接量可以拆分成数行，每行必须以反斜线（\）结束，反斜线和行结束符都不算是字符串直接量的内容。如果希望在字符串直接量中另起一行，可以使用转义字符\n（后续会有介绍）：
```javascript

"two\nlines"//这里定义了一个显示为两行的字符串
 //下面用三行代码定义了显示为单行的字符串，只在ECMAScript5中可用
"one\      
long\
line"
```
需要注意的是，当使用单引号来定界字符串时，需要格外小心英文中的缩写和所有格写法，比如can't和O'Reilly's。因为撇号和单引号是同一个字符，所以必须使用反斜杠（\）来转义（转义符将在下一章讲解）所有的撇号。

在客户端javascript程序设计中，javascript代码会夹杂HTML代码的字符串，HTML代码也会夹杂javascript代码。和javascript一样，HTML也使用单引号或者双引号来定界字符串，因此，当javascript代码和html代码混杂在一起的时候，最好在javascript和html代码中各自使用独立的引号风格。例如，在javascript表达式中使用单引号表示字符串“Thank you”，而在html事件处理程序属性中则使用双引号表示字符串：

    <button onclick="alert('Thank you')">Click Me</button>

**3.2.2转义字符**

在javascript字符串中，反斜杠(\)有着特殊的用途，反斜杠符号后面加一个字符，就不再表示它们的字面含义了，比如，\n就是一个转义字符（escape sequence），它表示的是一个换行符。escape sequence译为“转义序列”，有时也译成“转义字符”和“逃逸符”，本节中统一译为“转义字符”。

另一个例子是上节中提到的转义字符\'，表示单引号（或撇号）。当需要在一个单引号定界的字符串内使用撇号的时候，它就显得非常有用。现在你就会明白我们为什么把它们叫做转义字符了，因为反斜线可以使我们避免使用常规方式解释单引号，当单引号不是用来标记字符串结尾时，它只是一个撇号：
```javascript
'You\'re right, it can\'t be a quote'
```
表格3-1列出了javascript中的转义字符以及它们所代表的含义。其中有两个是通用的，通过十六进制数表示Latin-1或Unicode中的任意字码。例如，
\xA9表示版权符号，版权符号的Latin-1编码是十六进制数A9。同样，\u表示由4个十六进制数指定的任意Unicode字符，比如，\u03c0表示字符π。

表3-1 javascript转义字符

|转义字符|含义|
| -------- | ---- |
|\o|NUL字符（\u0000）|
|\b|退格符（\u0008）|
|\t|水平制表符（\u0009）|
|\n|换行符（\u000A）|
|\v|垂直制表符（\u000B）|
|\f|换页符（\u000C）|
|\r|回车符（\u000D）|
|\"|双引号（\u0022）|
|\'|撇号或单引号（\u0027）|
|\\|反斜线（\u005C）|
|\xXX|由两位十六进制数XX指定的Latin-1字符|
|\uXXXX|由4位十六进制数XXXX指定的Unicode字符|

如果”\“字符位于没有在表3-1中列出的字符前，则忽略”\“（当然，javascript语言将来的版本可能定义新的转义符）。比如”\#“和”#“等价。最后，上文提到过，在ECMAScript5中，允许在一个多行字符串直接量里的每行结束处使用反斜线。

**3.2.3字符串的使用**

javascript的内置功能之一就是字符串连接。如果将加号（+）运算符用于数字，表示两数相加。但将它作用于字符串，则表示字符串连接，将第二个字符串拼接在第一个之后，例如：
```javascript
msg = "Hello, " + "world";//生成字符串"Hello, world"
greeting = "Welcome to my blog," + " " + name;
```
要确定一个字符串长度——其所包含的16位值得个数——可以使用字符串的length属性。比如，要得到字符串s的长度：

    s.length
    
除了length属性，字符串还提供许多可以调用的方法（可以在第三部分查到详细信息）：
```javascript
var s = "hello, world" //定义一个字符串
s.charAt(0)//=>"h" 第一个字符
s.charAt(s.length - 1)//=>"d" 最后一个字符
s.substring(1,4)//=>"ell" 第2~4个字符
s.slice(1,4)//=>"ell" 同上
s.slice(-3)//=>"rld" 最后三个字符
s.indexOf("l")//=>2 字符l首次出现的位置
s.lastIndexOf("l")//=>10 字符l最后一次出现的位置
s.indexOf("l",3)//=>3 在位置3及之后首次出现字符l的位置
s.split(", ")//["hello", "world"]分割成子串
s.replace("h","H")//"Hello, world" 全文字符替换
s.toUpperCase()//"HELLO, WORLD" 
```
记住，在javascript中字符串是固定不变的，类似replace()和toUpperCase()的方法都返回新字符串，原字符串本身并没有发生改变。
在ECMAScript5中，字符串可以当做只读数组，除了使用charAt()方法，也可以使用方括号来访问字符串中的单个字符（16位值）：
```javascript
s = "hello, world";
s[0]//=>"h"
s[s.length -1] //=>"d"
```
基于Mozilla的web浏览器（比如Firefox）很久之前就支持这种方式的字符串索引，多数现代浏览器（IE除外）也紧跟Mozilla脚步，在ECMAScript5成型之前就支持了这一特性。

**3.2.4模式匹配**

javascript定义了RegExp()构造函数，用来创建表示文本匹配模式的对象。这些模式称为”正则表达式“（regular expression），javascript采用Perl中的正则表达式语法。String和RegExp对象均定义了利用正则表达式进行模式匹配和查找与替换的函数。、

RegExp并不是javascript的基本类型。和Date一样，它只是一种具有实用API的特殊对象。正则表达式的语法很复杂，API也很丰富。在第10章有详尽的文档介绍。RegExp是一种强大和常用的文本处理工具，本节只是一个概述。

尽管RegExp并不是语言中的基本数据类型，但是它们依然具有直接量写法，可以直接在javascript程序中使用。在两条斜线之间的文本构成了一个正则表达式直接量。第二条斜线之后也可以跟随一个或多个字母，用来修饰匹配模式的含义，例如：
```javascript
/^HTML/  //匹配以HTML开始的字符串
/[1-9][0-9]*/ //匹配一个非零数字，后面是任意个数字
/\bjavascript\b/  //匹配单词”javascript“，忽略大小写
```
RegExp对象定义了很多有用的方法，字符串同样具有可以接收RegExp参数的方法，例如：
```javascript
var text = "testing: 1, 2, 3";//文本示例
var pattern = /\d+g/  //匹配所有包含一个或多个数字的实例
pattern.test(text) //=>true 匹配成功
text.search(pattern) //=>9 首次匹配成功的位置
text.match(pattern) //=>["1", "2", "3"] 所有匹配组成的数组
text.replace(pattern, "#");//=> "testing: #, #, #"
text.split(/\D+/);//["","1","2","3"] 用非数字字符截取字符串
```

**3.3布尔值**

布尔值指代真或假、开或关、是或否。这个类型只有两个值，保留字true和false。
javascript程序中的比较语句的结果通常都是布尔值，例如：

    a==4
    
这段代码用来检测变量a的值是否等于4。如果等于，比较结果的布尔值就是true；如果不等，比较结果则为false。
布尔值通常用于javascript中的控制结构中。例如，javascript中的if／else语句，如果布尔值为true执行第一段逻辑，如果为false执行另一段逻辑。通常将一个创建布尔值的比较直接与使用这个比较的语句结合在一起，结果如下所示：

    if (a==4)
    b = b + 1;
    else
    a = a + 1;
    
这段代码检测变量a是否等于4，如果等于，则b加1，否则，a加1。我们同样会在3.8节讨论到，任意javascript的值都可以转换为布尔值。下面这些值会被转换成false：

    undefined
    null
    0
    -0
    NaN
    ""//空字符串
    
所有其他值，包括所有对象（数组）都会转换成true。false和上面6个可以转换成false的值有时称做“假值”（falsy value），其他值称做“真值”（truthy value）。
javascript期望使用一个布尔值的时候，假值会被当成false，真值会被当成true。

来看一个例子，假设变量o是一个对象或是null，可以通过一条if语句来显式地检测o是否是非null值：

    if (o !== null)

不等操作符“!==”将o和null比较，并得出结果为true或false。可以先忽略这里的比较语句，null是一个假值，对象是一个真值：

    if (o)
    
对于第一种情况，只有o不是null时才会执行if后的代码，第二种情况的限制没那么严格，只有o不是false或任何假值（比如null或undefined）时它才会执行这个if。到底选用哪条语句取决于期望赋给o的值是什么。如果需要将null与o或""区分开来，则需要使用一个显式的比较。

布尔值包含toString()方法，因此可以使用这个方法将字符串转换为“true”或“false”，但它并不包含其他有用的方法。除了这个不重要的API，还有三个重要的布尔运算符。

“&&”运算符执行了逻辑与（AND）操作。当且仅当两个操作数都是真值时它才返回true；否则返回false。“||”运算符是布尔或（OR）操作，如果两个操作数其中一个为真值它就返回true，如果两个操作数都是假值则返回false，最后，一元操作符“!”执行了布尔非（NOT）操作，如果操作数是真值则返回false，如果是假值，则返回true。
比如：

    if((x==0&&y==0)||!(z==0)){
        //x和y都是零或z是非零
    }

关于操作数的完整细节可以参照4.10节。
    
**3.4null和undefined**

null是javascript语言的关键字，它表示一个特殊值，常用来描述"空值"。对null执行typeof预算，结果返回字符串"object"，也就是说，可以将null认为是一个特殊的对象值，含义是”非对象“。但实际上，通常认为null是它自由类型的唯一一个成员，它可以表示数字、字符串和对象是”无值“的。大多数编程语言和javascript一样含有null；你可能对null和nil很眼熟。

javascript还有第二个值来表示值的空缺。用未定义的值表示更深层次的"空值"。它是变量的一种取值，表明变量没有初始化，如果要查询对象属性或数组元素的值时返回undefined则说明这个属性或元素不存在。如果函数没有返回任何值，则返回undefined。引用没有提供实参的函数的形参的值也只会得到undefined。undefined是预定义的全局变量（它和null不一样，它不是关键字），它的值就是“未定义”。在ECMAScript3中，undefined是可读/写的变量，可以给它赋予任意值。这个错误在ECMAScript5中做了修正；undefined在该版本中是只读的。如果使用typeof运算符得到undefined的类型，则返回“undefined”，表明这个值是这个类型的唯一成员。

尽管null和undefined是不同的，但它们都表示“值的空缺”，两者往往可以互换。判断相等运算符“==”认为两者是相等的（要使用严格相等运算符“===”来区分它们）。在希望值是布尔类型的地方它们的值都是假值，和false类似。null和undefined都不包含任何属性和方法。实际上，使用“.”和“[]”来存取这两个值的成员和方法都会产生一个类型错误。

你或许认为undefined是表示系统级的、出乎意料的或类似错误的值的空缺，而null是表示程序级的、正常的或在意料之中的值的空缺。如果你想将它们赋值给变量或者属性，或将它们作为参数传入函数，最佳选择是使用null。

**3.5全局对象**

前几节我们讨论了javascript的原始类型和原始值。对象类型——对象、数组和函数——在本书中均会有独立章节来讲述。但有一类非常重要的对象，我们不得不现在就把它们讲清楚——全局对象。
全局对象（global object）在javascript中有着重要的用途：全局对象的属性是全局定义的符号，javascript程序可以直接使用。当javascript解释器启动时（或者任何web浏览器加载新页面的时候），它将创建一个新的全局对象，并给它一组定义的初始属性：

* 全局属性，比如undefined、Infinity和NaN
* 全局函数，比如isNaN()、parseInt()（见3.8.2节）和eval()（见4.12节）
* 构造函数，比如Date()、RegExp()、String()、Object()和Array()（见3.8.2节）
* 全局对象，比如Math和JSON（见6.9节）

全局对象的初始属性并不是保留字，但它们应该当做保留字来对待。2.4.1节列出了所有这些属性。本章对一部分全局属性也有描述。其他属性在其他章节也会讲述。可以在第三部分中通过名称查找到，或者通过别名“Global”来找到这些全局对象。对于客户端javascript来讲，window对象定义了一些额外的全局属性，可以在第四部分中查看它们。

在代码的最顶级——不在任何函数内的javascript代码——可以使用javascript关键字this来引用全局对象：

    var global = this;//定义一个引用全局对象的全局变量

在客户端javascript中，在其表示的浏览器窗口中的所有javascript代码中，window对象充当了全局对象。这个全局window对象有一个属性window引用其自身，它可以代替this来引用全局对象。window对象定义了核心全局属性，但它也针对web浏览器和客户端javascript定义了一少部分其他全局属性。
当初次创建的时候，全局对象定义了javascript中所有的预定义全局值。这个特殊对象同样包含了为程序定义的全局值。如果代码声明了一个全局变量，这个全局变量就是全局对象的一个属性，3.10.2节有关于此的详尽解释。

**3.6包装对象**

javascript对象是一种复合值：它是属性或已命名值的集合。通过“.”符号来引用属性值。当属性值是一个函数的时候，称其为方法。通过o.m()来调用对象o中的方法。

我们看到字符串也同样具有属性和方法：
```javascript
var s = "hello world!";//一个字符串
var word = s.substring(s.indexOf(" ")+1, s.length);//使用字符串的属性
```
字符串既然不是对象，为什么它会有属性呢？只要引用了字符串s的属性。javascript就会将字符串值通过调用new String(s)的方式转换成对象，这个对象继承了字符串的方法（见6.2.2节），并被用来处理属性的引用。一旦属性引用结束，这个新创建的对象就会销毁（其实在实现上并不一定创建或销毁这个临时对象，然而整个过程看起来是这样）。
同字符串一样，数字和布尔值也具有各自的方法：通过NUmber()和Boolean()构造函数创建一个临时对象，这些方法的调用均是来自于这个临时对象。null和undefined没有包装对象：访问它们的属性会造成一个类型错误。

看如下代码，思考它们的执行结果：
```javascript
var s = "test";//创建一个字符串
s.len = 4;//给它设置一个属性
var t = s.len;//查询这个属性
```
当运行这段代码时，t的值是undefined。第二行代码创建一个临时字符串对象，并给其len属性赋值4，随即销毁这个对象。第三行通过原始的（没有修改过）字符串值创建一个新字符串对象，尝试读取其len属性，这个属性自然是不存在的，表达式求值结果为undefined。这段代码说明了在读取字符串、数字和布尔值的属性值（或方法）的时候，表现的像对象一样。但如果你试图给其属性赋值，则会忽略这个操作：修改只是发生在临时对象身上，而这个临时对象并未继续保留下来。

存取字符串、数字或布尔值的属性时创建的临时对象称做包装对象，它只是偶尔用来区分字符串值和字符串对象、数字和数值对象以及布尔值和布尔对象。通常，包装对象只是被看做是一种实现细节，而不用特别关注。由于字符串、数字和布尔值的属性都是只读的，并且不能给它们定义新属性，因此你需要明白它们是有别于对象。
lei
需要注意的是，可通过String()、Number()或Boolean()构造函数来显式创建包装对象：
```javascript
var s = "test",n = 1,b = true;//一个字符串、数字和布尔值
var S = new String(s);//一个字符串对象
var N = new Number(n);//一个数值对象
var B = new Boolean(b);//一个布尔对象
```
javascript会在必要时将将包装对象转换为原始值，因此上段代码中的对象S、N和B常常但不总是表现的和s、n和b一样。“==”等于运算符将原始值和其包装对象视为相等，但“===”全等运算符将它们视为不等。通过typeof运算符可以看到原始值和其包装对象的不同。

**3.7不可变的原始值和可变的对象引用**

javascript中的原始值（undefined、null、布尔值、数字和字符串）与对象（包括数组和函数）有着根本的区别。原始值是不可更改的，任何方法都无法更改（或“突变”）一个原始值。对数字和布尔值来说显然如此——改变数字的值本身就说不通，而对字符串来说就不那么明显了，因为字符串看起来就像是由字符组成的数组，我们期望可以通过指定索引来修改字符串中的字符。实际上，javascript是禁止这样做的。字符串中所有的方法看上去返回了一个修改后的字符串，实际上返回的是一个新的字符串值。例如：
```javascript
var s = "hello";//定义一个由小写字母组成的文本
s.toUpperCase();//返回“HELLO”，但并没有改变s的值
s               //=> hello，原始字符串的值并未改变
```
原始值的比较是值的比较：只有在它们的值相等时它们才相等。这对数字、布尔值、null和undefined来说听起来有点难懂，并没有其他办法来比较它们。同样，对于字符串来说则并不明显：如果比较两个单独的字符串，当且仅当它们的长度相等且每个索引的字符都相等时，javascript才认为它们相等。

对象和原始值不同，首先，它们是可变的——它们的值是可修改的：
```javascript
var o = {x:1};//定义一个对象
o.x = 2;//通过修改对象属性值来更改对象
o.y = 3;//再次更改这个对象，给它增加一个新属性
var a = [1,2,3]//数组也是可修改的
a[0] = 0;//更改数组的一个元素
a[3] = 4;//给数组增加一个新元素
```
对象的比较并非值的比较，即使两个对象包含同样的属性及相同的值，它们也是不相等的。各个索引元素完全相等的两个数组也不相等。
```javascript
var o = {x:1},p = {x:1}//具有相同属性的两个对象
o===p//=>false 两个单独的对象永不相等
var a = [],b = [];//两个单独的空数组
a===b//=>false 两个单独的数组永不相等
```
我们通常将对象称为引用类型（reference type），以此来和javascript的基本类型区分开来。依照术语的叫法，对象值都是引用（reference）。对象的比较均是引用的比较，当且仅当它们引用同一个基对象时，它们才相等。
```javascript
var a = [];//定义一个引用空数组的变量s
var b = a;//变量b引用同一个数组
b[0] = 1;//通过变量b来修改引用的数组
a[0]//=>1 变量a也会修改
a===b//=>true a和b引用同一个数组，因此它们相等
```
就像你们看到的如上代码，将对象（或数组）赋值给一个变量，仅仅是赋值的引用值，对象本身并没有复制一次，如果你想得到一个对象或数组的副本，则必须显式复制对象的每个属性或数组的每个元素。下面这个例子则是通过循环来完成数组复制（见5.5.3节）。
```javascript
var a = ['a','b','c'];//待复制的数组
var b = [];//复制到的目标空数组
for(var i=0; i<a.length; i++){//遍历a[]中的每个元素
    b[i] = a[i];//将元素值复制到b中
}
```
同样的，如果我们想比较两个单独的对象或者数组，则必须比较它们的属性或元素。下面这段代码定义了一个比较两个数组的函数；
```javascript
function equalArrays(a,b){
    if(a.length != b.length) return false;//两个长度不同的数组不相等
    for(var i=0; i<a.length; i++){//循环遍历所有元素
        if (a[i] !== b[i]) return false;//如果有任意元素不等，则数组不相等
        return true;//否则它们相等
    }
}
```
**3.8类型转换**

javascript中的取值类型非常灵活，我们已经从布尔值看到了这一点：当javascript期望使用一个布尔值的时候，你可以提供任意类型值，javascript将根据需要自行转换类型。一些值（真值）转换为true，其他值（假值）转换为false。这在其他类型中同样适用：如果javascript期望使用一个字符串，它把给定的值将转换为字符串。如果javascript期望使用一个数字，它把给定的值将转换为数字（如果转换结果无意义的话将返回NaN），一些例子如下：
```javascript
10 + " objects"//=>"10 objects"，数字10转换成字符串
"7" * "4" //=> 28 两个字符串均转换为数字
var n = 1 - "x";//=>NaN 字符“x”无法转换为数字
n + " objects"//“NaN objects” NaN转换为字符串“NaN”
```
表3-2简要说明了在javascript中如何进行类型转换。

表3-2：javascript类型转换

|原始值|字符串|数字|布尔值|对象|
|:-----:|:--------:|:-------:|:-----:|:------:|
|undefined|"undefined"|NaN|false|throws TypeError|
|null|"null"|0|false|throws TypeError|
|true|"true"|1|true|new Boolean(true)|
|false|"false"|0|false|new Boolean(false)|
|""(空字符串)|"" |0|false|new String("")|
|"1.2"(非空，数字)|"1.2" |1.2|true|new String("1.2")|
|"one"(非空，非数字)|"one" |NaN|true|new String("one")|
|0|"0" |0|false|new Number(0)|
|-0|"0" |-0|false|new Number(-0)|
|NaN|"NaN"|NaN|false|new Number(NaN)|
|Infinity|"Infinity"|Infinity|true|new Number(Infinity)|
|-Infinity|"-Infinity"|Infinity|true|new Number(-Infinity)|
|1（无穷大，非零）|"1"|1|true|new Number(1)|
|{}（任意对象）|参考3.8.3节|参考3.8.3节|true|{}|
|[]（任意数组）|""|0|true|[]|
|[9]（1个数字元素）|"9"|9|true|[9]|
|['a']（其他数组）|使用join()方法|NaN|true|['a']|
|function(){}（任意函数）|参考3.8.3节|NaN|true|function(){}|

表3-2节中提到的原始值到原始值的转换相对简单，我们已经在3.3节讨论过转换为布尔值的情况了。
所有原始值转换为字符串的情形也已经明确定义。转换为数字的情形比较微妙。那些以数字表示的字符串可以直接转换为数字，也允许在开始和结尾处带有空格。但在开始和结尾处的任意非空格字符都不会被当成数字直接量的一部分，进而造成字符串转换为数字的结果为NaN。有一些数字转换看起来让人奇怪：true转换为1，false、空字符串和""转换为0。

原始值到对象的转换也非常简单，原始值通过调用String()、Number()或Boolean()构造函数，转换为它们各自的包装对象（见3.6节）。

null和undefined属于例外，当将它们用在期望是一个对象的地方都会造成一个类型错误（TypeError）异常，而不会执行正常的转换。

对象到原始值的转换多少有些复杂，3.8.3节将以此为专题专门讲述。

**3.8.1转换和相等性**

由于javascript可以做灵活的类型转换，因此其“==”相等运算符也随相等的含义灵活多变。例如，如下这些比较结果均是true：
```javascript
null == undefined//这两值被认为相等
"0" == 0//在比较之前字符串转换为数字
0 == false//在比较之前布尔值转换为数字
"0" == false//在比较之前字符串和布尔值都转换为数字
```
4.9.1节详细讲解了“==”等于运算符在判断两个值是否相等时做了哪些类型转换，并同样介绍了“===”恒等运算符在判断相等时未做任何类型转换。

需要特别注意的是，一个值转换为另一个值并不意味着两个值相等。比如，如果在期望使用布尔值的地方使用了undefined，它将会转换为false，但这并不表明undefined == false。javascript运算符和语句期望使用多样化的数据类型，并可以相互转换。if语句将undefined转换为false，但“==”运算符从不试图将其操作数转换为布尔值。

**3.8.2显式类型转换**

尽管javascript可以自动做许多类型转换，但有时仍需要做显式转换，或者为了代码变得清晰易读而做显式转换。

做显式类型转换最简单的方法就是使用Boolean()、Number()、String()或Object()函数。
我们在3.6节已经介绍过了。当不通过new运算符调用这些函数时，它们会作为类型转换函数并按照表3-2所描述的规则做类型转换：
```javascript
Number("3")//=>3
String(false)//=>"false"或使用false.toString()
Boolean([])//=>true
Object(3)//=> new Number(3)
```
需要注意的是，除了null或undefined之外的任何值都具有toString()方法，这个方法的执行结果通常和String()方法的返回结果一致。
同样需要注意的是，如果试图把null或undefined转换为对象，则会像表3-2所描述的那样抛出一个类型错误（TypeError）。
Object()函数在这种情况下不会抛出异常：它仅简单地返回一个新创建的空对象。

javascript中的某些运算符会做隐式的类型转换，有时用于类型转换。如果“+”运算符的一个操作数是字符串，它将会把另外一个操作数转换为字符串。一元“+”运算符将其操作数转换为数字。同样，一元“!”运算符将其操作数转换为布尔值并取反。在代码中会经常见到这种类型转换的惯用法：
```javascript
x + "" //等价于String(x)
+x //等价于Number(x) 也可以写成x-0
!!x //等价于Boolean(x)，注意是双叹号
```
在计算机程序中数字的解析和格式化是非常普通的工作，javascript中提供了专门的函数和方法用来做更加精确的数字到字符串（number-to-string）和字符串到数字（string-to-number）的转换。

Number类定义的toString()方法可以接收表示转换基数（radix）的可选参数，如果不指定此参数，转换规则将是基于十进制的。同样，亦可以将数字转换为其他进制数（范围在2~36之间），例如：
```javascript
var n = 17;
binary_string = n.toString(2);//转换为“10001”
octal_string = "0" + n.toString(8);//转换为“021”
hex_string = "0x" + n.toString(16);//转换为“0x11”
```
当处理财务或科学数据的时候，在做数字到字符串的转换过程中，你期望自己控制输出中小数点位置和有效数字位数，或者决定是否需要指数记数法。Number类为这种数字到字符串的类型转换场景定义了三个方法。toExponential()使用指数记数法将数字转换为指数形式的字符串，其中小数点前只有一位，小数点后的位数则由参数指定（也就是说有效数字位数比指定的位数要多一位），toPrecision()根据指定的有效数字位数将数字转换为字符串。如果有效数字的位数少于数字整数部分的位数，则转换成指数形式。我们注意到，所有三个方法都会适当地进行四舍五入或填充0。看一下下面几个例子：
```javascript
var n = 123456.789;
n.toFixed(0);//"123457"
n.toFixed(2);//"123456.79"
n.toFixed(5);//"123456.78900"
n.toExponential(1);//"1.2e+5"
n.toExponential(3);//"1.235e+5"
n.toPrecision(4);//"1.235e+5"
n.toPrecision(7);//"123456.8"
n.toPrecision(10);//"123456.7890"
```
如果通过Number()转换函数传入一个字符串，它会试图将其转换为一个整数或浮点数直接量，这个方法只能基于十进制数进行转换，并且不能出现非法的尾随字符。parseInt()函数和parseFloat()函数（它们是全局函数，不从属于任何类的方法）更加灵活。parseInt()只解析整数，而parseFloat()则可以解析整数和浮点数。如果字符串前缀是“0x”或者“0X”，parseInt()将其解释为十六进制数，parseInt()和parseFloat()都会跳过任意数量的前导空格，尽可能解析更多数值字符，并忽略后面的内容。如果第一个非空格字符是非法的数字直接量，将最终返回NaN：
```javascript
parseInt("3 blind mice")//=>3
parseFloat(" 3.14 meters");//=>3.14
parseInt("-12.34");//=>-12
parseInt("0xFF");//=>255
parseInt("0xff");//=>255
parseInt("-0xFF");//=>-255
parseFloat(".1");//=>0.1
parseInt("0.1");//=>0
parseInt(".1");//=>NaN 整数不能以“.”开始
parseInt("$72.47");//=>NaN 数字不能以“$”开始
```
parseInt()可以接收第二个可选参数，这个参数指定数字转换的基数，合法的取值范围是2~36，例如：
```javascript
parseInt("11",2);//=>3 (1*2+1)
parseInt("ff",16);//=>255 (15*16 + 15)
parseInt("zz",36);//=>1295 (35*36 + 35)
parseInt("077",8);//=>63 (7*8 + 7)
parseInt("077",10);//=>63 (7*10 + 7)
```

**3.8.3对象转换为原始值**
对象到布尔值的转换非常简单：所有的对象（包括数组和函数）都转换为true。对于包装对象亦是如此：new Boolean(false)是一个对象而不是原始值，它将转换为true。

对象到字符串（object-to-string）和对象到数字（object-to-number）的转换是通过调用待转换对象的一个方法来完成的。一个麻烦的事实是，javascript对象有两个不同的方法来执行转换，并且接下来要讨论的一些特殊场景更加复杂。值得注意的是，这里提到的字符串和数字的转换规则只适用于本地对象（native object）。宿主对象（例如，由web浏览器定义的对象）根据各自的算法可以转换成字符串和数字。

所有的对象继承了两个转换方法。第一个是toString(),它的作用是返回一个反映这个对象的字符串。默认的toString()方法并不会返回一个有趣的值（在例6-4中我们会发现它非常有用）：

    ({x:1, y:2}).toString() // => "[object object]"

很多类定义了更多特定版本的toString()方法。例如，数组类(Array class)的toString()方法将每个数组元素转换为一个字符串，并在元素之间添加逗号后合并成结果字符串。
函数类（functtion class）的toString()方法返回这个函数的实现定义的表示方式。实际上，这里的实现方式是通常是将用户定义的函数转换为javascript源代码字符串。日期类（Date class）定义的toString()方法返回了一个可读的（可被javascript解析的，这里的原文是javascript-parsable，意指可以通过javascript的方法过滤并再做封装）日期和时间字符串。
RegExp类（RegExp class）定义的toString()方法将RegExp对象转换为表示正则表达式直接量的字符串：
```javascript
[1,2,3].toString() //=>"1,2,3"
(function(x){f(x);}).toString()//=>"function(x){\n f(x); \n}"
/\d+/g.toString() // => "/\\d+/g"
new Date(2010,0,1).toString()//=> "Fri Jan 01 2010 00:00:00 GMT-0800(PST)"
```
另一个转换对象的函数是valueOf()。这个方法的任务并未详细定义：如果存在任意原始值，它就默认将对象转换为表示它的原始值。对象是复合值，而且大多数对象无法真正表示为一个原始值，因此默认的valueOf()方法简单地返回对象本身，而不是返回一个原始值。数组、函数和正则表达式简单地继承了这个默认方法，调用这些类型的实例的valueOf()方法只是简单返回对象本身。日期类定义的valueOf()方法会返回它的一个内部表示：1970年1月1日依来的毫秒数。
```javascript
var d = new Date(2010,0,1);//2010年1月1日（太平洋时间）
d.valueOf() //=> 1262332800000
```
通过使用我们刚刚讲解过的toString()和valueOf()方法，就可以做到对象到字符串和对象到数字的转换了。但需要注意的是，在某些特殊的场景中，javascript执行了完全不同的对象到原始值的转换。这些特殊场景在本节的最后会讲到。
javascript中对象到字符串的转换经过了如下这些步骤：

* 如果对象具有toString()方法，则调用这个方法。如果它返回一个原始值，javascript将这个值转换为字符串（如果本身不是字符串的话），并返回这个字符串结果。需要注意的是，原始值到字符串的转换在表3-2中已经有了详尽的说明。
* 如果对象没有toString()方法，或者这个方法并不返回一个原始值，那么javascript会调用valueOf()方法。如果存在这个方法，则javascript调用它。如果返回值是原始值，javascript将这个值转换为字符串（如果本身不是字符串的话），并返回这个字符串结果。
* 否则，javascript无法从toString()或valueOf()获得一个原始值，因此这时它将抛出一个类型错误异常。

在对象到数字的转换过程中，javascript做了同样的事情，只是它会首先尝试使用valueOf()方法：

* 如果对象具有valueOf()方法，后者返回一个原始值，则javascript将这个原始值转换为数字（如果需要的话）并返回这个数字。
* 否则，如果对象具有toString()方法，后者返回一个原始值，则javascript将其转换并返回。
* 否则，javascript抛出一个类型错误异常。

对象转换为数字的细节解释了为什么空数组会被转换为数字0以及为什么具有单个元素的数组同样会转换成一个数字。数组继承了默认的valueOf()方法，这个方法返回一个对象而不是一个原始值，因此，数组到数字的转换则调用toString()方法。空数组转换为空字符串，空字符串转换成为数字0。含有一个元素的数组转换为字符串的结果和这个元素转换字符串的结果一样。如果数组只包含一个数字元素，这个数字转换为字符串，再转换回数字。

javascript中的“+”运算符可以进行数学加法和字符串连接操作。如果它的其中一个操作数是对象，则javascript将使用特殊的方法将对象转换为原始值，而不是使用其他算术运算符的方法执行对象到数字的转换，“==”相等运算符与此类似。如果将对象和一个原始值比较，则转换将会遵照对象到原始值的转换方式进行。

“+”和“==”应用的对象到原始值的转换包含日期对象的一种特殊情形。日期类是javascript语言核心中唯一的预先定义类型，它定义了有意义的向字符串和数字类型的转换。对于所有非日期的对象来说，对象到原始值的转换基本上是对象到数字的转换（首先调用valueOF()），日期对象则使用对象到字符串的转换模式，然而，这里的转换和上文讲述的并不完全一致：通过valueOf或toString()返回的原始值将被直接使用，而不会被强制转换为数字或字符串。

和“==”一样，“<”运算符以及其他关系运算符也会做对象到原始值的转换，但要除去日期对象的特殊情形：任何对象都会首先尝试调用valueOf()，然后调用toString()。不管得到的原始值是否直接使用，它都不会进一步被转换为数字或字符串。

“+”、“==”、“!=”和关系运算符是唯一执行这种特殊的字符串到原始值的转换方式的运算符。其他运算符到特定类型的转换都很明确，而且对日期对象来讲也没有特殊情况。例如“-”减号运算符把它的两个操作数都转换为数字。下面的代码展示了日期对象和“+”、“-”、“==”以及“>”的运行结果：
```javascript
var now = new Date();//创建一个日期对象
typeof (now + 1)//=>"string"  "+"将日期转换为字符串
typeof (now - 1)//=> "number" "-"使用对象到数字的转换
now == now.toString() //=>true 隐式的和显式的字符串转换
now > (now - 1)//=>true ">"将日期转换为数字
```
**3.9变量声明**

在javascript程序中，使用一个变量之前应当先声明。变量是使用关键字var来声明的，如下所示：
```javascript
var i;
var sum;
```
也可以通过一个var关键字来声明多个变量：
```javascript
var i,sum;
```
而且还可以将变量的初始赋值和变量声明合写在一起：
```javascript
var message = "hello";
var i = 0, j = 0, k = 0;
```

我们未在var声明语句中给变量指定初始值，那么虽然声明了这个变量，但在给它存入一个值之前，它的初始值就是undefined。

我们注意到，在for和for/in循环（在第5章会讲到）中同样可以使用var语句，这样可以更简洁地声明在循环体语法内中使用的循环变量。例如：
```javascript
for(var i = 0; i < 10; i++) console.log(i);
for(var i = 0, j = 10; i<10; i++,j--) console.log(i*j);
for(var p in o) console.log(p);
```
如果你之前编写过诸如c或java的静态语言，你会注意到在javascript的变量声明中并没有指定变量的数据类型。javascript变量可以是任意数据类型。例如，在javascript中首先将数字赋值给一个变量，随后再将字符串赋值给这个变量，这是完全合法的：
```javascript
var i = 10;
i = "ten";
```
重复的声明和遗漏的声明：
使用var语句重复声明变量是合法且无害的。如果重复声明带有初始化器，那么这就和一条简单的赋值语句没什么两样。
如果你试图读取一个没有声明的变量的值，javascript会报错。在ECMAScript5严格模式（见5.7.3节）中，给一个没有声明的变量赋值也会报错。然而从历史上讲，在非严格模式下，如果给一个未声明的变量赋值，javascript实际上会给全局对象创建一个同名属性，并且它工作起来像（但并不完全一样，查看3.10.2节）一个正确声明的全局变量。这意味着你可以侥幸不声明全局变量。但这是一个不好的习惯并会造成很多bug，因此，你应当始终使用var来声明变量。

**3.10变量作用域**

一个变量的作用域（scope）是程序源代码中定义这个变量的区域。全局变量拥有全局作用域，在javascript代码中的任何地方都是有定义的。
然而在函数内声明的变量只在函数体内有定义。它们是局部变量，作用域是局部性的。函数参数也是局部变量，它们只在函数体内有定义。
在函数体内，局部变量的优先级高于同名的全局变量。如果在函数内声明的一个局部变量或者函数参数中带有的变量和全局变量重名，那么全局变量就被局部变量所遮盖。

```javascript
var scope = "global";   //声明一个全局变量
function checkscope() {
    var scope = "local";//声明一个同名的局部变量
    return scope;       //返回局部变量的值，而不是全局变量的值
}
checkscope();           //=>"local"
```
尽管在全局作用域编写代码时可以不写var语句，但声明局部变量时则必须使用var语句。思考一下如果不这样做会怎样：

```javascript
scope = "global";           //声明一个全局变量，甚至不用var来声明
function checkscope2() {    
    scope = "local";        //糟糕！我们刚刚修改了全局变量
    myscope = "local";      //这里显式地声明了一个新的全局变量
    return [scope,myscope]; //返回两个值
}
checkscope2();//=>["local","local"]，产生了副作用
scope//=>"local"，全局变量修改了
myscope//=>"local"，全局命名空间搞乱了
```
函数定义是可以嵌套的。由于每个函数都有它自己的作用域，因此会出现几个局部作用域嵌套的情况，例如：

```javascript
var scope = "global scope";//全局变量
    function checkscope() {
        var scope = "local scope";//局部变量
        function nested() {
            var scope = "nested scope";//nested(嵌套)，嵌套作用域内的局部变量
            return scope;//返回当前作用域内的值
        }
        return nested();
    }
checkscope(); //"nested scope"，嵌套作用域
```

**3.10.1函数作用域和声明前提**

在一些类似c语言的编程语言中，花括号内的每一段代码都具有各自的作用域，而且变量在声明它们的代码段之外是不可见的，我们称为块级作用域（block scope），而javascript中没有块级作用域。
javascript取而代之地使用了函数作用域（function scope），变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的。

在如下所示的代码中，在不同位置定义了变量i、j和k，它们都在同一个作用域内——这三个变量在函数体内均是有定义的。

```javascript
function test(o){
    var i = 0;                      //i在整个函数体内均是有定义的
    if(typeof o == "object") {
        var j = 0;                  //j在函数体内是有定义的，不仅仅是在这个代码段内
        for (var k=0; k < 10; k++){ //k在函数体内是有定义的，不仅仅是在循环里
            console.log(k);         //输出数字0～9
        }
        console.log(k);             //k已经定义了，输出10
    }           
    console.log(j);                 //j已经定义了，但可能没有初始化
}
```
javascript的函数作用域是指在函数内声明的所有变量在函数体内始终是可见的。有意思的是，这意味着变量在声明之前甚至已经可用。javascript的这个特性被非正式地称为声明前提（hoisting），即javascript函数里声明的所有变量（但不涉及赋值）都被提前至函数体的顶部，看一下如下代码：

```javascript
var scope = "global";
function f() {
    console.log(scope);//输出"undefined"，而不是"global"
    var scope = "local";//变量在这里赋初始值，但变量本身在函数体内任何地方均是有定义的
    console.log(scope);//输出"local"
}
```
你可能会误以为函数中的第一行会输出“global”，因为代码还没有执行到var语句声明局部变量的地方。其实不然，由于函数作用域的特性，局部变量在整个函数体始终是有定义的，也就是说，在函数体内局部变量遮盖了同名全局变量。尽管如此，只有在程序执行到var语句的时候，局部变量才会被真正赋值。因此，上述过程等价于：将函数内的变量声明“提前”至函数体顶部，同时变量初始化留在原来的位置：

```javascript
function f() {
    var scope;//在函数顶部声明了局部变量
    console.log(scope);//变量存在，但其值是"undefined"
    scope = "local";//这里将其初始化并赋值
    console.log(scope);//这里它具有了我们所期望的值
}
```
在具有块级作用域的编程语言中，在狭小的作用域里让变量声明和使用变量的代码尽可能靠近彼此，通常来讲，这是一个非常不错的编程习惯。由于javascript没有块级作用域，因此一些程序员特意将变量声明放在函数体顶部，而不是将声明靠近在使用变量之处。这种做法使得他们的源代码非常清晰地反映了真实的变量作用域。

“声明提前”这步操作是在javascript引擎的“预编译”时进行的，是在代码开始运行之前，更多细节请阅读相关ppt：www.slideshare.net/lijing00333/javascript-engine。

**3.10.2作为属性的变量**

当声明一个javascript全局变量时，实际上是定义了全局对象的一个属性（3.5节）。当使用var声明一个变量时，创建的这个属性是不可配置的（见6.7节），也就是说这个变量无法通过delete运算符删除。可能你已经注意到了，如果你没有使用严格模式并给一个未声明的变量赋值的话，javascript会自动创建一个全局变量。以这种方式创建的变量是全局对象的正常的可配值属性，并可以删除它们。

```javascript
var truevar = 1;//声明一个不可删除的全局变量
fakevar = 2;//创建全局对象的一个可删除的属性
this.fakevar2 = 3;//同上
delete truevar //=>false 变量并没有被删除
delete fakevar //=>true 变量被删除
delete this.fakevar2 //=>true 变量被删除
```

javascript全局变量是全局对象的属性，这是在ECMAScript规范中强制规定的。对于局部变量则没有如此规定，但我们可以想象得到，局部变量当做跟函数调用相关的某个对象的属性。ECMAScript3规范称该对象为“调用对象”（call object），ECMAScript5规范称“声明上下文对象”（declarative environment record）。javascript可以允许使用this关键字来引用全局对象，却没有方法可以引用局部变量中存放的对象。这种存放局部变量的对象的特有性质，是一种对我们不可见的内部实现。然而，这些局部变量对象存在的观念是非常重要的。我们会在下一节展开讲述。

**3.10.3作用域链**
javascript是基于词法作用域的语言：通过阅读包含变量定义在内的数行源码就能知道变量的作用域。全局变量在程序中始终都是有定义的。局部变量在声明它的函数体内以及其所嵌套的函数内始终是有定义的。

如果将一个局部变量看做是自定义实现的对象的属性的话，那么可以换个角度来解读变量作用域。每一段javascript代码（全局代码或函数）都有一个与之关联的作用域链（scope chain）。
这个作用域链是一个对象列表或者链表，这组对象定义了这段代码“作用域中”的变量。当javascript需要查找变量x的值的时候（这个过程称做“变量解析”（variable resolution）），它会从链中的第一个对象开始查找，如果这个对象有一个名为x的属性，则会直接使用这个属性的值，如果第一个对象中不存在名为x的属性，javascript会继续查找链上的下一个对象。如果第二个对象依然没有名为x的属性，则会继续查找下一个对象，以此类推。如果作用域链上没有任何一个对象含有属性x，那么就认为这段代码的作用域链上不存在x，并最终抛出一个引用错误（ReferenceError）异常。

在javascript的最顶层代码中（也就是不包含在任何函数定义内的代码），作用域链由一个全局对象组成。在不包含嵌套的函数体内，作用链上有两个对象，第一个是定义函数参数和局部变量的对象，第二个是全局对象。在一个嵌套的函数体内，作用域链上至少有三个对象。理解对象链的创建规则是非常重要的。当定义一个函数时，它实际上保存一个作用域链。当调用这个函数时，它创建一个新的对象来存储它的局部变量，并将这个对象添加至保存的那个作用域链上，同时创建一个新的更长的表示函数调用作用域的“链”。对于嵌套函数来讲，事情变得更加有趣，每次调用外部函数时，内部函数又会重新定义一遍。因为每次调用外部函数的时候，作用域链都是不同的。内部函数在每次定义的时候都有微妙的差别——在每次调用外部函数时，内部函数的代码都是相同的，而且关联这段代码的作用域链也不相同。

作用域链的概念对于理解with语句（见5.7.1节）是非常有帮助的，同样对理解闭包（见8.6节）的概念也至关重要。


表达式和运算符
--------------

表达式（expression）javascript中的一个短语，javascript解释器会将其计算（evaluate）出一个结果。程序中的常量是最简单的一类表达式。变量名也是一种简单的表达式，它的值就是赋值给变量的值。复杂表达式是由简单表达式组成的。比如，数组访问表达式是由一个表示数组的表达式、左方括号、一个整数表达式和右方括号构成。它们所组成的新的表达式的运算结果是该数组的特定位置的元素值。同样的，函数调用表达式由一个表示函数对象的表达式和0个或多个参数表达式构成。

将简单表达式组合成复杂表达式最常用的方法就是使用运算符（operator）。运算符按照特定的运算规则对操作数（通常是两个）进行运算，并计算出新值。乘法运算符“*”是比较简单的例子。表达式x＊y是对两个变量表达式x和进行运算并得出结果。有时我们更愿意说运算符返回一个值而不是“计算”出一个值。

本章将讲解所有的javascript运算符，同时也讲解不涉及运算符的表达式（比如访问数组元素和函数调用）。如果你熟悉C语法风格的其他编程语言，你会发现大多数javascript表达式和运算符都似曾相识。

**4.1原始表达式**

最简单的表达式是“原始表达式”（primary expression）。
原始表达式是表达式的最小单位——它们不再包含其他表达式。javascript中的原始表达式包含常量或直接量、关键字和变量。
直接量是直接在程序中出现的常数值。它们看起来像：

    1.23       //数字直接量
    "hello"    //字符串直接量
    /pattern/  //正则表达式直接量

javascript数字直接量的语法在3.1节已经做了讲解。字符串直接量在3.2节做了讲解。正则表达式直接量语法在3.2.4节做了简单介绍，在第10章将做专门讲解。
javascript中的一些保留字构成了原始表达式：

    true//返回一个布尔值，真
    false//返回一个布尔值，假
    null//返回一个值，空
    this//返回“当前”对象

我们在3.3节和3.4节中学习了true、false和null。和其他关键字不同，this并不是一个常量，它在程序的不同地方返回的值也不相同。this关键字经常在面向对象编程中出现。在一个方法体内，this返回调用这个方法的对象。参照4.5节、第8章（8.2.2节）和第9章来获取关于this的详细信息。

最后，第三种原始表达式是变量：

    i//返回变量i的值
    sum//返回sum的值
    undefined//undefined是全局变量，和null不同，它不是一个关键字
    
当javascript代码中出现标志符，javascript会将其当做变量而去查找它的值。如果变量名不存在，表达式运算结果为undefined。然而，在ECMAScript5的严格模式中，对不存在的变量进行求值会抛出一个引用错误异常。    

**4.2对象和数组的初始化表达式**
**4.3函数定义表达式**
**4.4属性访问表达式**
**4.5调用表达式**
**4.6对象创建表达式**
对象创建表达式（object creation expression）创建一个对象并调用一个函数（这个函数称为构造函数）初始化新对象的属性。对象创建表达式和函数调用表达式非常类似，只是对象创建表达式之前多了一个关键字new：
```javascript
new Object()
new Point(2,3)
```
如果一个对象创建表达式不需要传入任何参数给构造函数的话，那么这对空圆括号是可以省略掉的：
```javascript
new Object
new Date
```
当计算一个对象创建表达式的值时，和对象初始化表达式通过{}创建对象的做法一样，javascript首先创建一个新的空对象，然后，javascript通过传入指定的参数并将这个新对象当做this的值来调用一个指定的函数。这个函数可以使用this来初始化这个新创建对象的属性。那些被当做构造函数的函数不会返回一个值，并且这个新创建并被初始化后的对象就是整个对象创建表达式的值。如果一个构造函数确实返回了一个对象值，那么这个对象就作为整个对象创建表达式的值，而新创建的对象就废弃了。

**4.7运算符概述**
**4.8算术表达式**
**4.9关系表达式**

本节介绍javascript的关系运算符。关系运算符用于测试两个值之间的关系（比如“相等”，“小于”，或“是……的属性”），根据关系是否存在返回true或false。关系表达式总是返回一个布尔值，通常if、while或者for语句（参照第5章）中使用关系表达式，用以控制程序的执行流程。接下来的几节将会讲述相等和不等运算符、比较运算符和javascript中其他两个关系运算符in和instanceof。

**4.9.1相等和不等运算符**

“==”和“===”运算符用于比较两个值是否相等，当然它们对相等的定义不尽相同。两个运算符允许任意类型的操作数，如果操作数相等则放回true，否则返回false。“===”也称为严格相等运算符（strict equality）（有时也称做恒等运算符（identity operator）），它用来检测两个操作数是否严格相等。“==”运算符称做相等运算符（equality operator），它用来检测两个操作数是否相等，这里“相等”的定义非常宽松，可以允许进行类型转换。

javascript支持“=”、“==”和“===”运算符。你应当理解这些（赋值、相等、恒等）运算符之间的区别，并在编码过程中小心使用，尽管它们都可以称做“相等”，但为了减少概念混淆，应该把“=”称做“得到或赋值”，把“==”称做“相等”，把“===”称做严格相等。

“!=”和“!==”运算符的检测规则是“==”和“===”运算符的求反。如果两个值通过“==”的比较结果为true，那么通过“!=”的比较结果则为false。如果两值通过“===”的比较结果为true，那么通过“!==”的比较结果则为false。4.10节会提到，“!”运算符是布尔非运算符。我们只要记住“!=”称做“不相等”、“!===”称做“不严格相等”就可以了。

**4.9.2比较运算符**
**4.9.3in运算符**

in运算符希望它的左操作数是一个字符串或可以转换为字符串，希望它的右操作数是一个对象。如果右侧的对象拥有一个名为左操作数值的属性名，那么表达式返回true，例如：
```javascript
var point = {x:1,y:1};//定义一个对象
"x" in point;//=>true 对象有一个名为“x”的属性
"z" in point;//=>false 对象中不存在名为“z”的属性
"toString" in point;//=>true 对像继承了toString()方法

var data = [7,8,9];//拥有三个元素的数组
"0" in data;//=>true 数组包含元素“0”
1 in data;//=>true 数字转换为字符串
3 in data;//=>false 没有索引为3的元素
```

**4.9.4instanceof运算符**

instanceof运算符希望左操作数是一个对象，右操作数标识对象的类。如果左侧对象是右侧的类的实例，则表达式返回true；否则返回false。第9章将会讲到，javascript中对象的类是通过初始化它们的构造函数来定义的。这样的话，instanceof的右操作数应当是一个函数。比如：
```javascript
var d = new Date();//通过Date()构造函数来创建一个新对象
d instanceof Date();//计算结果为true，d是由Date()创建的
d instanceof Object();//计算结果为true，所有对象都是Object的实例
d instanceof Number();//计算结果为false，d不是一个Number对象
var a = [1,2,3];//通过数组直接量的方法创建一个数组
a instanceof Array;//计算结果为true，a是一个数组
a instanceof Object;//计算结果为true，所有的数组都是对象
a instanceof RegExp;//计算结果为false，数组不是正则表达式
```
需要注意的是，所有的对象都是Object的实例。当通过instanceof判断一个对象是否是一个类的实例的时候，这个判断也会包含对“父类”(superclass)的检测。如果instanceof的左操作数不是对象的话，instanceof返回false。如果右操作数不是函数，则抛出一个类型错误异常。

为了理解instanceof运算符是如何工作的，必须首先理解“原型链”（prototype chain）。
原型链作为javascript的继承机制，将在6.2.2节详细描述。为了计算表达式o instanceof f，javascript首先计算f.prototype，然后在原型链中查找o，如果找到，那么o是f（或者f的父类）的一个实例，表达式返回true。如果f.prototype不在o的原型链中的话，那么o就不是f的实例，instanceof返回false。
对象o中存在一个隐藏的成员，这个成员指向其父类的原型，如果父类的原型是另外一个类的实例的话，则这个原型对象中也存在一个隐藏成员指向另一个类的原型，这种链条将许多对象或类串接起来，既是原型链。原文所讲f.prototype不在o的原型链中也就是说f和o没有派生关系，更多细节请参照6.2.2节。


**4.10逻辑表达式**

逻辑运算符“&&”、“||”和“!”是对操作数进行布尔算术运算，经常和关系运算符一起配合使用，逻辑运算符将多个关系表达式组合起来组成一个更复杂的表达式。这些运算符在下面几节中会一一讲述，为了更好地理解它们，应当首先回顾一下3.3节提到的“真值”和“假值”的概念。

**4.11赋值表达式**
**4.12表达式计算**

和其他很多解释性语言一样，javascript同样可以解释运行由javascript源代码组成的字符串，并产生一个值。javascript通过全局函数eval()来完成这个工作：

    eval("3+2")//=>5

动态判断源代码中的字符串是一种强大的语言特性，几乎没有必要在实际中应用。如果你使用来eval(),你应当仔细考虑是否真的需要使用它。
**4.13其他运算符**
javascript支持很多其他各种各样的运算符，后续几节详细讨论它们。
**4.13.1条件运算符(?:)**
**4.13.2typeof运算符**
**4.13.3delete运算符**

delete是一元操作符，它用来删除对象属性或者数组元素，就像赋值、递增、递减运算符一样，delete也具有副作用的，它是用来做删除操作的，不是用来返回一个值的，例如：
```javascript
var o = {x:1,y:2};//定义一个对象
delete o.x;//删除一个属性
"x" in o;  //=>false 这个属性在对象中不再存在
var a = [1,2,3];//定义一个数组
delete a[2];//删除最后一个数组元素
2 in a;//=>false 元素2在数组中已经不存在了
a.length;//=>3 注意，数组长度并没有改变，尽管上一行代码删除了这个元素，但删除操作留下了一个“洞”，实际上并没有修改数组的长度，因此a数组的长度仍然是3
```
需要注意的是，删除属性或者删除数组元素不仅仅是设置了一个undefined的值。当删除一个属性时，这个属性将不再存在。读取一个不存在的属性将返回undefined，但是可以通过in运算符（见4.9.3节）来检测这个属性是否在对象中存在。

delete希望他的操作数是一个左值，如果它不是左值，那么delete将不进行任何操作同时返回true。否则，delete将试图删除这个指定的左值。如果删除成功，delete将返回true。然而并不是所有的属性都可删除，一些内置核心和客户端属性是不能删除的，用户通过var语句声明的变量不能删除。同样，通过function语句定义的函数和函数参数也不能删除。
在ECMAScript5严格模式中，如果delete的操作数是非法的，比如变量、函数或函数参数，delete操作将抛出一个语法错误（SyntaxError）异常，只有操作数是一个属性访问表达式（见4.4节）时候它才会正常工作。在严格模式下，delete删除不可配置的属性（参照6.7节）时会抛出一个类型错误异常。在非严格模式中，这些delete操作都不会报错，只是简单地返回false，以表明操作数不能执行删除操作。
这里有一些关于delete运算符的例子：
```javascript
var o = {x:1,y:2};  //定义一个变量，初始化为对象
delete o.x;         //删除一个对象属性，返回true
typeof o.x;         //属性不存在，返回“undefined”
delete o.x;         //删除不存在的属性，返回true
delete o;           //不能删除通过var声明的变量，返回false
                    //在严格模式下，将抛出一个异常
delete 1;           //参数不是一个左值，返回true
this.x = 1;         //给全局对象定义一个属性，这里没有使用var
delete x;           //试图删除它，在非严格模式下返回true
                    //在严格模式下会抛出异常，这时使用“delete this.x”来代替
x;                  //运行时错误，没有定义x
```
6.3节还会有关于delete操作符的讨论。

**4.13.4void运算符**
**4.13.5逗号运算符(,)**


语句
----

第4章提到，表达式在javascript中是短语，那么语句（statement）就是javascript整句或命令。正如英文是用句号作结尾来分隔语句，javascript语句是以分号结束（见2.5节）。表达式计算出一个值，但语句用来执行以使某件事发生。

“使某事发生”的一个方法是计算带有副作用的表达式。诸如赋值和函数调用这些有副作用的表达式，是可以作为单独的语句的，这种把表达式当做语句的用法也称做表达式语句（expression statement）。类似的语句还有声明语句（declaration statement），声明语句用来声明新变量或定义新函数。

javascript程序无非就是一系列可执行语句的集合。默认情况下，javascript解释器依照语句的编写顺序依次执行。另一种“使某件事发生”的方法是改变语句的默认执行顺序。javascript中有很多语句和控制结构（control structure）来改变语句的默认执行顺序：

* 条件（conditional）语句，javascript解释器可以根据一个表达式的值来判断是执行还是跳过这些语句，如if语句和switch语句。
* 循环（loop）语句，可以重复执行语句，如while和for语句。
* 跳转（jump）语句，可以让解释器跳转至程序的其他部分继续执行，如break、return和throw语句。

接下来几节将介绍javascript中各式各样的语句及其语法。本章最后的表5-1对这些语句作了总结。一个javascript程序无非是一个以分号分隔的语句集合，所以一旦掌握了javascript语句，就可以开始编写javascript程序了。

**5.1表达式语句**

**5.2复合语句和空语句**

**5.3声明语句**

**5.4条件语句**

**5.5循环**

为了理解条件语句，可以将在javascript中的代码想象成一条条的分支路径。循环语句（looping statement）就是程序路径的一个回路。可以让一部分代码重复执行。javascript中有4种循环语句：while、do/while、for和for/in。下面几节将会依次讲解它们。其中最常用的循环就是对数组元素的遍历，7.6节详细讨论这种循环和使用数组类定义的特殊循环方法。
**5.5.1while**

**5.5.2do/while**

**5.5.3for**

**5.5.4for/in**

for/in语句也使用for关键字，但它是和常规的for循环完全不同的一类循环。for/in循环语句的语法如下：

    for(variable in object) statement

variable通常是一个变量名，也可以是一个可以产生左值的表达式或者一个通过var语句声明的变量，总之必须是一个适用于赋值表达式左侧的值。Object是一个表达式，这个表达式的计算结果是一个对象。同样，statement是一个语句或语句块，它构成了循环的主体。
使用for循环来遍历数组元素是非常简单的：
```javascript
for (var i = 0; i < a.length; i++)//i代表来数组元素的索引
    console.log(a[i]);//输出数组中的每个元素
```
而for/in循环则是用来更方便地遍历对象属性成员：
```javascript
for (var p in o)//将属性的名字赋值给变量p
console.log(o[p]);//输出每一个属性的值
```

**5.6跳转**

**5.7其他语句类型**

**5.8javascript语句小结**




